/* Simple +/-/* expression language; parser evaluates constant expressions on the fly*/
/**
 *  Package and Import Specifications
 */
import java_cup.runtime.*;

/**
 *  Usercode Components
 */
parser code {:
    // Connect this parser to a scanner!
    Scanner s;
    Parser(Scanner s){ this.s=s; }
:}

/* define how to connect to the scanner! */
scan with {: return s.next_token(); :};

/**
 *  Symbol Lists
 */

/* Terminals (tokens returned by the scanner). */
terminal            SEMI, CONCAT, MINUS, TIMES, LPAREN, RPAREN, IF, WHILE, FOR, ELSE , PREFIX,REVERSE,PRINT,RBRACET,LBRACET,COMA;
terminal String     STRING_LITERAL,IDENT;        // our scanner provides numbers as strings

/*  Non terminals */
non terminal expr_list;
non terminal expr;      // used to store evaluated subexpressions
non terminal String     statement,body;
non terminal booleanEx;
non terminal String     ifElse;
non terminal String     prefixList;
non terminal String     Epsilon;
non terminal String     EpsilonTail;
non terminal String     EpsilonTail2;
non terminal printFormat;
non terminal String funcDec, funcCall;
non terminal String,argsList,argsListTail,funcDecList;
non terminal myClass;
non terminal  J;
/**
 *  Precedence Declarations
 */
precedence left  MINUS,CONCAT;
precedence left IF,ELSE,TIMES;
precedence right REVERSE;

/**
 *  The Grammar Rules
 */

expr_list ::=expr:e  {:System.out.println();:};


expr      ::= statement:stm                                {: System.out.printf("\npublic class Main {\n");
                                                           System.out.printf("  public static void main(String[] args) {\n");
                                                           System.out.printf("\t%s",stm);
                                                           System.out.printf(" }\n");
                                                           System.out.printf("}");
                                                           :}
           | funcDecList:f                                  {:System.out.printf("%s",f);:};
myclass::=SEMI {: class MyClass{String s1="k";}; MyClass myclass=new MyClass(); System.out.printf("%s\n",myclass.s1);:};
body::=statement:bodyFunction                     {:RESULT = bodyFunction;:};

statement::=ifElse:ifElse                         {: RESULT=ifElse; :}
            |TIMES                             // {: System.out.printf("}"); :}
            ;

ifElse ::= IF LPAREN prefixList:prefixList RPAREN
                 statement:stm1
              ELSE
                 statement:stm2
                 {:
                    RESULT=  "if ("+prefixList+") {"+System.getProperty("line.separator")+
                    "\t"+stm1+System.getProperty("line.separator")+"\t} else {"+System.getProperty("line.separator")+"\t"+stm2+"}";
                 :};

//booleanEx ::= IDENT:str1 PREFIX IDENT:str2        {: RESULT=(str2.startsWith(str1)); System.out.println(str2.startsWith(str1));:};

prefixList::= Epsilon:str1 PREFIX Epsilon:str2 prefixList  {:RESULT=str1+".startsWith("+str2+")";:}
              |;
Epsilon::= EpsilonTail:et EpsilonTail2:et2                 {:String s=et+et2; RESULT =s;:};

EpsilonTail2::= CONCAT Epsilon:epsilon                     {: RESULT="+"+epsilon;:}
                |                                          {: RESULT="";:}
                ;

EpsilonTail::= IDENT:string                                {:RESULT='"'+string+'"';:}
              | REVERSE EpsilonTail:epsilonTail            {:
                                                                String newString="",str=epsilonTail;
                                                                char character;
                                                                for (int i=0; i<epsilonTail.length(); i++)
                                                                   {
                                                                     character= str.charAt(i); //extracts each character
                                                                     newString= character+newString; //adds each character in front of the existing string
                                                                   }
                                                                   RESULT=newString;:};


funcDecList::= funcDec:fd funcDecList:fdl                            {:RESULT=fd+fdl;:}
               |funcCall:fc funcDecList:fdl                          {:RESULT=fc+fdl;:}
               |                                                     {:RESULT="";:};

funcDec::= IDENT:functionName LPAREN argsList:myArgs RPAREN LBRACET body:funcBody RBRACET   {:RESULT="public static String "+functionName+"( "+myArgs+" ){"
                                                                                                +System.getProperty("line.separator")+"\t"+funcBody+" }"+"\n";
                                                                                                //System.out.printf("\n%s",RESULT);
                                                                                                :};

argsList::= IDENT:argument argsListTail:nextArguments                         {: RESULT="String "+argument+nextArguments;:}
            |;

argsListTail::= COMA IDENT:argument argsListTail:nextArguments                {: RESULT =", "+"String "+argument+nextArguments;:}
            |                                                                 {:RESULT="";:};

funcCall::=IDENT:functionName LPAREN argsList:myArgs RPAREN                   {:RESULT="function call\n";System.out.println("Function call\n");:};